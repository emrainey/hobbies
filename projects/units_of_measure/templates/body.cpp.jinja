///
/// @file
/// This is an auto-generated source for {{namespace}}::{{classname}}.
/// {{comment}}
/// @note See README on re-generation.
/// @copyright Copyright {{year}}.
///
#include "{{namespace}}/{{classname}}.hpp"

namespace {{namespace}} {
char const* const suffix_type_{{postfix}}::suffix;
// default
{{classname}}::{{classname}}() : measurement{} {
}
// explicit value
{{classname}}::{{classname}}({{typename}} a) : measurement{a} {
}
// copy constructor
{{classname}}::{{classname}}({{classname}} const& other) : measurement{other} {
}
// move constructor
{{classname}}::{{classname}}({{classname}}&& other) : measurement{std::move(other)} {
}

{{classname}}& {{classname}}::operator=({{classname}} const& other) noexcept {
    _value = other.value;
    return (*this);
}
{{classname}}& {{classname}}::operator=({{classname}}& other) noexcept {
    _value = other.value;
    return (*this);
}
{{classname}}& {{classname}}::operator=({{classname}}&& other) noexcept {
    _value = other.value;
    return (*this);
}
bool {{classname}}::operator==({{classname}} const& other) const {
    return basal::equivalent(value, other.value);
}
bool {{classname}}::operator!=({{classname}} const& other) const {
    return !operator==(other);
}
{{classname}}& {{classname}}::operator+=({{classname}} const& other) {
    _value += other.value;
    return (*this);
}
{{classname}}& {{classname}}::operator-=({{classname}} const& other) {
    _value -= other.value;
    return (*this);
}
{{classname}}& {{classname}}::operator*=({{typename}} factor) {
    _value *= factor;
    return (*this);
}
{{classname}}& {{classname}}::operator/=({{typename}} factor) {
    _value /= factor;
    return (*this);
}
{{classname}} {{classname}}::operator-() const {
    return {{classname}}{-value};
}
bool {{classname}}::operator<({{classname}} const& other) const {
    return (_value < other.value);
}
bool {{classname}}::operator<=({{classname}} const& other) const {
    return (_value <= other.value);
}
bool {{classname}}::operator>({{classname}} const& other) const {
    return (_value > other.value);
}
bool {{classname}}::operator>=({{classname}} const& other) const {
    return (_value >= other.value);
}
namespace operators {
{{classname}} operator+({{classname}} const& A, {{classname}} const& B) {
    return {{classname}}{A.value + B.value};
}
{{classname}} operator-({{classname}} const& A, {{classname}} const& B) {
    return {{classname}}{A.value - B.value};
}
{{classname}} operator*({{classname}} const& A, {{typename}} factor) {
    return {{classname}}{A.value * factor};
}
{{classname}} operator*({{typename}} factor, {{classname}} const& A) {
    return {{classname}}{A.value * factor};
}
{{classname}} operator/({{classname}} const& A, {{typename}} factor) {
    return {{classname}}{A.value / factor};
}
precision operator/({{classname}} const& A, {{classname}} const& B) {
    return A.value / B.value;
}
}  // namespace operators
namespace literals {
iso::{{classname}} operator""_{{postfix}}(long double a) {
    return iso::{{classname}}(static_cast<precision>(a));
}
iso::{{classname}} operator""_{{postfix}}(unsigned long long a) {
    return iso::{{classname}}(static_cast<precision>(a));
}
iso::{{classname}} operator""_{{postfix}}(char const a[]) {
    iso::precision p = static_cast<iso::precision>(atol(a));
    return iso::{{classname}}(p);
}
}  // namespace literals
}  // namespace iso


