#include <raytrace/raytrace.hpp>

#include "world.hpp"

using namespace raytrace;
using namespace raytrace::objects;
using namespace raytrace::lights;
using namespace raytrace::colors;
using namespace raytrace::operators;

/// A star field that is generated by a choosing random points on a golden spiral on the unit sphere.
class StarField {
public:
    StarField(size_t count) : count{count}, star_vectors{} {
        ComputeStarVectors();
    }

    raytrace::color operator()(raytrace::vector const& world_vector) const {
        // classify the vector to find which quadrant it belongs to
        Index quad = Classify(world_vector);
        // search the quadrant list for a star which closely matches the vector by checking the dot product and comparing to nearly 1.0
        for (size_t i = 0; i < star_vectors[quad.index].size(); ++i) {
            auto d = dot(star_vectors[quad.index][i], world_vector);
            auto const limit = 1.0f - epsilon;
            if (d > limit) {
                // interpolate the color based on the distance from the center
                auto diff = (1.0f - d) * scale; // should now be 0 to 1
                return interpolate(colors::black, colors::white, diff);
            }
        }
        return colors::black;
    }

private:
    static constexpr precision scale{1'048'576.0f};
    static constexpr precision epsilon{1.0f / scale};
    static constexpr size_t limit = 6 * scale; ///< the number of possible locations for a star on the golden spiral

    enum class Type : uint8_t {
        Space = 0,
        SmallStar = 1,
        Nebula = 2,
        LargeStar = 3
    };

    struct Index {
        Index() : index{0}, type{Type::Space} {}
        uint8_t index : 3; // 0-7 quadrants
        Type type     : 2;
        uint8_t       : 3;
    };

    Index Classify(raytrace::vector const& vec) const {
        Index quad;
        // classify the quadrant that the vector belongs to
        if (vec[0] >= 0.0f) { quad.index |= 0b001; }
        if (vec[1] >= 0.0f) { quad.index |= 0b010; }
        if (vec[2] >= 0.0f) { quad.index |= 0b100; }
        return quad;
    }

    void ComputeStarVectors() {

        // compute a ray
        for (size_t i = 0; i < count; ++i) {
            // pick a random number
            auto s = basal::rand_range(0.0f, static_cast<precision>(limit));
            // make it a size_t
            auto j = static_cast<size_t>(s);
            // compute a random point in space on the unit sphere by picking a point
            // on the golden spiral which is on the unit sphere. Convert that point
            // to a vector by subtracting the origin.
            auto vec = raytrace::vector{raytrace::mapping::golden_ratio_mapper(j, limit) - R3::origin};
            // classify the vector to find which quadrant it belongs to
            Index quad = Classify(vec);
            // store the vector in one of the 8 quadrants of the star_vectors
            star_vectors[quad.index].push_back(vec);
        }
    }

    // memory for the stars
    size_t const count;
    std::vector<raytrace::vector> star_vectors[8];
};

// Good results at values of depth=8, subsamples=16, 1024x768, fov=23
class PlanetWorld : public world {
public:
    PlanetWorld()
        : look_from{0, 50, 10}
        , look_at{8, 0, 0}
        , sun_rays{raytrace::vector{-20, 0, -21}, colors::white, lights::intensities::bright / 2}
        , inner_light{raytrace::point{0, 0, 80}, colors::white, lights::intensities::blinding}
        , center{0, 0, 0}
        , ringA{center, R3::basis::Z, 10.0, 11.8}
        , ringB{center, R3::basis::Z, 12.0, 12.2}
        , ringC{center, R3::basis::Z, 12.4, 13.2}
        , ringD{center, R3::basis::Z, 14.0, 14.2}
        , ringE{center, R3::basis::Z, 14.5, 14.7}
        , ringF{center, R3::basis::Z, 15.0, 16.7}
        , planet{center, 1.0}
        , starfield{1024} {
        planet.material(&mediums::metals::stainless);
        ringA.material(&mediums::metals::stainless);
        ringB.material(&mediums::metals::stainless);
        ringC.material(&mediums::metals::stainless);
        ringD.material(&mediums::metals::stainless);
        ringE.material(&mediums::metals::stainless);
        ringF.material(&mediums::metals::stainless);
        planet.scale(7.5_p, 7.5_p, 7.5_p); // use scaling instead of a larger radius
    }

    ~PlanetWorld() = default;

    raytrace::point& looking_from() override {
        return look_from;
    }

    raytrace::point& looking_at() override {
        return look_at;
    }

    std::string window_name() const override {
        return std::string("Planet World");
    }

    std::string output_filename() const override {
        return std::string("world_planet.tga");
    }

    raytrace::color background(raytrace::ray const& world_ray) const override {
        // starfield background
        return starfield(world_ray.direction());
    }

    void add_to(scene& scene) override {
        // scene.add_light(&inner_light);
        scene.add_light(&sun_rays);
        scene.add_object(&planet);
        scene.add_object(&ringA);
        scene.add_object(&ringB);
        scene.add_object(&ringC);
        scene.add_object(&ringD);
        scene.add_object(&ringE);
        scene.add_object(&ringF);
    }

    raytrace::animation::anchors get_anchors() const override {
        raytrace::animation::anchors anchors;
        anchors.push_back(
            animation::Anchor{
                animation::Attributes{look_from, look_at, 55.0},
                animation::Attributes{look_from, look_at, 55.0},
                animation::Mappers{}, iso::seconds{1.0_p}
            });
        return anchors;
    }

protected:
    raytrace::point look_from;
    raytrace::point look_at;
    lights::beam sun_rays;
    lights::speck inner_light;
    raytrace::point center;
    objects::ring ringA;
    objects::ring ringB;
    objects::ring ringC;
    objects::ring ringD;
    objects::ring ringE;
    objects::ring ringF;
    objects::sphere planet;
    StarField starfield;
};

// declare a single instance and return the reference to it
world* get_world() {
    static PlanetWorld my_world;
    return &my_world;
}
