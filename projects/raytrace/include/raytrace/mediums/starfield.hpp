#include "raytrace/types.hpp"
#include "raytrace/color.hpp"

namespace raytrace {
namespace mediums {
/// A star field that is generated by a choosing random points on a golden spiral on the unit sphere.
class StarField {
public:
    StarField(size_t count) : count{count}, star_vectors{} {
        ComputeStarVectors();
    }

    raytrace::color operator()(raytrace::vector const& world_vector) const {
        // classify the vector to find which quadrant it belongs to
        Index quad = Classify(world_vector);
        // search the quadrant list for a star which closely matches the vector by checking the dot product and
        // comparing to nearly 1.0
        for (size_t i = 0; i < star_vectors[quad.index].size(); ++i) {
            auto d = dot(star_vectors[quad.index][i], world_vector);
            auto const limit = 1.0f - epsilon;
            if (d > limit) {
                // interpolate the color based on the distance from the center
                auto diff = (1.0f - d) * scale;  // should now be 0 to 1
                return interpolate(colors::black, colors::white, diff);
            }
        }
        return colors::black;
    }

private:
    static constexpr precision scale{1'048'576.0f};
    static constexpr precision epsilon{1.0f / scale};
    static constexpr size_t limit = 6 * scale;  ///< the number of possible locations for a star on the golden spiral

    enum class Type : uint8_t {
        Space = 0,
        SmallStar = 1,
        Nebula = 2,
        LargeStar = 3
    };

    struct Index {
        Index() : index{0}, type{Type::Space} {
        }
        uint8_t index : 3;  // 0-7 quadrants
        Type type : 2;
        uint8_t : 3;
    };

    Index Classify(raytrace::vector const& vec) const {
        Index quad;
        // classify the quadrant that the vector belongs to
        if (vec[0] >= 0.0f) {
            quad.index |= 0b001;
        }
        if (vec[1] >= 0.0f) {
            quad.index |= 0b010;
        }
        if (vec[2] >= 0.0f) {
            quad.index |= 0b100;
        }
        return quad;
    }

    void ComputeStarVectors() {
        // compute a ray
        for (size_t i = 0; i < count; ++i) {
            // pick a random number
            auto s = basal::rand_range(0.0f, static_cast<precision>(limit));
            // make it a size_t
            auto j = static_cast<size_t>(s);
            // compute a random point in space on the unit sphere by picking a point
            // on the golden spiral which is on the unit sphere. Convert that point
            // to a vector by subtracting the origin.
            auto vec = raytrace::vector{raytrace::mapping::golden_ratio_mapper(j, limit) - R3::origin};
            // classify the vector to find which quadrant it belongs to
            Index quad = Classify(vec);
            // store the vector in one of the 8 quadrants of the star_vectors
            star_vectors[quad.index].push_back(vec);
        }
    }

    // memory for the stars
    size_t const count;
    std::vector<raytrace::vector> star_vectors[8];
};

}  // namespace mediums
}  // namespace raytrace